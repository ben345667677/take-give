name: Production Deployment

on:
  workflow_run:
    workflows: ["Run Tests"]
    types:
      - completed
    branches:
      - main

# Prevent concurrent deployments to avoid conflicts
concurrency:
  group: production-deployment
  cancel-in-progress: false

env:
  DEPLOYMENT_DIR: /opt/trade-give
  HEALTH_CHECK_TIMEOUT: 120
  HEALTH_CHECK_INTERVAL: 5
  MAX_ROLLBACK_ATTEMPTS: 1

jobs:
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest

    # Only deploy if tests passed successfully
    if: ${{ github.event.workflow_run.conclusion == 'success' }}

    timeout-minutes: 30

    outputs:
      deployment-status: ${{ steps.deployment.outcome }}
      deployment-url: ${{ steps.verify.outputs.url }}

    steps:
      - name: Deployment Start Notification
        id: deployment-start
        run: |
          echo "::notice::üöÄ Starting production deployment"
          echo "Commit: ${{ github.sha }}"
          echo "Triggered by: ${{ github.event.workflow_run.event }}"
          echo "Test status: ${{ github.event.workflow_run.conclusion }}"
          echo "deployment-time=$(date -u +%s)" >> $GITHUB_OUTPUT

      - name: Setup SSH Configuration
        id: ssh-setup
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/deploy_key.pem
          chmod 600 ~/.ssh/deploy_key.pem
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts
          echo "‚úÖ SSH configuration completed"

      - name: Pre-deployment Health Check
        id: pre-check
        continue-on-error: true
        run: |
          echo "üîç Checking current deployment status..."
          if curl -f -s --max-time 10 http://${{ secrets.EC2_HOST }}/api/health > /dev/null 2>&1; then
            echo "current-status=healthy" >> $GITHUB_OUTPUT
            echo "‚úÖ Current deployment is healthy"
          else
            echo "current-status=unhealthy" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Current deployment is not responding"
          fi

      - name: Deploy Application
        id: deployment
        env:
          SSH_KEY: ~/.ssh/deploy_key.pem
          SSH_USER: ${{ secrets.EC2_USER }}
          SSH_HOST: ${{ secrets.EC2_HOST }}
          DEPLOY_DIR: ${{ env.DEPLOYMENT_DIR }}
          REPO: ${{ github.repository }}
        run: |
          ssh -i $SSH_KEY -o StrictHostKeyChecking=no $SSH_USER@$SSH_HOST bash -s << 'DEPLOY_SCRIPT'
          set -euo pipefail

          # Color codes for output
          RED='\033[0;31m'
          GREEN='\033[0;32m'
          YELLOW='\033[1;33m'
          BLUE='\033[0;34m'
          NC='\033[0m' # No Color

          log_info() { echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"; }
          log_success() { echo -e "${GREEN}‚úÖ $1${NC}"; }
          log_warning() { echo -e "${YELLOW}‚ö†Ô∏è  $1${NC}"; }
          log_error() { echo -e "${RED}‚ùå $1${NC}"; }

          DEPLOY_DIR="${DEPLOY_DIR:-/opt/trade-give}"
          REPO="${REPO}"
          BACKUP_DIR="/tmp/backup-$(date +%Y%m%d-%H%M%S)"

          log_info "Starting deployment to $DEPLOY_DIR"

          # Function to check if command exists
          command_exists() {
            command -v "$1" &> /dev/null
          }

          # Detect OS
          if [ -f /etc/os-release ]; then
            . /etc/os-release
            OS=$ID
            log_info "Detected OS: $OS"
          fi

          # Install prerequisites
          install_prerequisites() {
            log_info "Checking and installing prerequisites..."

            # Git installation
            if ! command_exists git; then
              log_warning "Git not found. Installing..."
              if [ "$OS" = "amzn" ] || [ "$OS" = "centos" ] || [ "$OS" = "rhel" ]; then
                sudo yum install -y git
              elif [ "$OS" = "ubuntu" ] || [ "$OS" = "debian" ]; then
                sudo apt-get update && sudo apt-get install -y git
              fi
              log_success "Git installed: $(git --version)"
            else
              log_success "Git already installed: $(git --version)"
            fi

            # Docker installation
            if ! command_exists docker; then
              log_warning "Docker not found. Installing..."
              if [ "$OS" = "amzn" ] || [ "$OS" = "centos" ] || [ "$OS" = "rhel" ]; then
                sudo yum update -y
                sudo yum install -y docker
                sudo systemctl start docker
                sudo systemctl enable docker
                sudo usermod -aG docker $USER
              elif [ "$OS" = "ubuntu" ] || [ "$OS" = "debian" ]; then
                sudo apt-get update
                sudo apt-get install -y docker.io
                sudo systemctl start docker
                sudo systemctl enable docker
                sudo usermod -aG docker $USER
              fi
              log_success "Docker installed successfully"
            else
              log_success "Docker already installed"
              sudo systemctl start docker || true
            fi

            # Docker Compose installation
            if ! command_exists docker-compose; then
              log_warning "docker-compose not found. Installing..."
              sudo curl -sL "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
              log_success "docker-compose installed: $(docker-compose --version)"
            else
              log_success "docker-compose already installed: $(docker-compose --version)"
            fi
          }

          # Create backup of current deployment
          backup_current_deployment() {
            if [ -d "$DEPLOY_DIR" ] && [ -f "$DEPLOY_DIR/docker-compose.yml" ]; then
              log_info "Creating backup of current deployment..."
              mkdir -p "$BACKUP_DIR"
              cd "$DEPLOY_DIR"
              sudo docker-compose ps --format json > "$BACKUP_DIR/containers-state.json" || true
              cp -r "$DEPLOY_DIR" "$BACKUP_DIR/app" || true
              log_success "Backup created at $BACKUP_DIR"
              echo "$BACKUP_DIR"
            else
              log_info "No existing deployment to backup"
              echo ""
            fi
          }

          # Rollback function
          rollback() {
            local backup_path=$1
            if [ -n "$backup_path" ] && [ -d "$backup_path" ]; then
              log_warning "Rolling back to previous version..."
              cd "$DEPLOY_DIR"
              sudo docker-compose down || true
              if [ -d "$backup_path/app" ]; then
                sudo rm -rf "$DEPLOY_DIR"/*
                sudo cp -r "$backup_path/app/"* "$DEPLOY_DIR/"
                sudo docker-compose up -d
                log_success "Rollback completed"
              fi
            fi
          }

          # Main deployment
          install_prerequisites

          BACKUP_PATH=$(backup_current_deployment)

          # Setup deployment directory
          log_info "Setting up deployment directory..."
          sudo mkdir -p "$DEPLOY_DIR"
          sudo chown $USER:$USER "$DEPLOY_DIR"
          cd "$DEPLOY_DIR"

          # Clone or update repository
          if [ -d ".git" ]; then
            log_info "Updating repository..."
            git fetch origin
            CURRENT_COMMIT=$(git rev-parse HEAD)
            git reset --hard origin/main
            NEW_COMMIT=$(git rev-parse HEAD)
            log_success "Updated from $CURRENT_COMMIT to $NEW_COMMIT"
          else
            log_info "Cloning repository..."
            if [ "$(ls -A .)" ]; then
              log_warning "Directory not empty, cleaning..."
              rm -rf ./* ./.[!.]* 2>/dev/null || true
            fi
            git clone "https://github.com/${REPO}.git" .
            log_success "Repository cloned successfully"
          fi

          # Create .env file if needed
          if [ ! -f .env ]; then
            log_warning "Creating .env file..."
            cat > .env << 'ENVEOF'
          DB_HOST=db
          DB_PORT=3306
          DB_USER=appuser
          DB_PASSWORD=SecurePass2025!
          DB_NAME=loginapp
          MYSQL_ROOT_PASSWORD=RootPass2025!
          MYSQL_DATABASE=loginapp
          MYSQL_USER=appuser
          MYSQL_PASSWORD=SecurePass2025!
          JWT_SECRET=SuperSecretJWT2025ChangeMe!
          PORT=3000
          NODE_ENV=production
          ENVEOF
            log_success ".env file created"
          fi

          # Stop existing containers gracefully
          log_info "Stopping existing containers..."
          sudo docker-compose down --timeout 30 || true

          # Build new images
          log_info "Building Docker images..."
          if sudo docker-compose build --no-cache; then
            log_success "Docker images built successfully"
          else
            log_error "Build failed!"
            if [ -n "$BACKUP_PATH" ]; then
              rollback "$BACKUP_PATH"
            fi
            exit 1
          fi

          # Start new containers
          log_info "Starting new containers..."
          if sudo docker-compose up -d; then
            log_success "Containers started successfully"
          else
            log_error "Failed to start containers!"
            if [ -n "$BACKUP_PATH" ]; then
              rollback "$BACKUP_PATH"
            fi
            exit 1
          fi

          # Health checks
          log_info "Performing health checks..."

          # Database health check
          log_info "Checking database health..."
          timeout=120
          elapsed=0
          while [ $elapsed -lt $timeout ]; do
            if sudo docker-compose ps db | grep -q "healthy"; then
              log_success "Database is healthy"
              break
            fi
            if [ $elapsed -ge $timeout ]; then
              log_error "Database health check timeout!"
              sudo docker-compose logs --tail=50 db
              if [ -n "$BACKUP_PATH" ]; then
                rollback "$BACKUP_PATH"
              fi
              exit 1
            fi
            echo "Waiting for database... ($elapsed/$timeout seconds)"
            sleep 5
            elapsed=$((elapsed + 5))
          done

          # Backend health check
          log_info "Checking backend health..."
          timeout=120
          elapsed=0
          while [ $elapsed -lt $timeout ]; do
            if curl -f -s http://localhost:3000/api/health > /dev/null 2>&1; then
              log_success "Backend is healthy"
              break
            fi
            if [ $elapsed -ge $timeout ]; then
              log_error "Backend health check timeout!"
              sudo docker-compose logs --tail=50 backend
              if [ -n "$BACKUP_PATH" ]; then
                rollback "$BACKUP_PATH"
              fi
              exit 1
            fi
            echo "Waiting for backend... ($elapsed/$timeout seconds)"
            sleep 5
            elapsed=$((elapsed + 5))
          done

          # Nginx health check
          log_info "Checking Nginx health..."
          timeout=60
          elapsed=0
          while [ $elapsed -lt $timeout ]; do
            if curl -f -s http://localhost/health > /dev/null 2>&1; then
              log_success "Nginx is healthy"
              break
            fi
            if [ $elapsed -ge $timeout ]; then
              log_error "Nginx health check timeout!"
              sudo docker-compose logs --tail=50 nginx
              if [ -n "$BACKUP_PATH" ]; then
                rollback "$BACKUP_PATH"
              fi
              exit 1
            fi
            echo "Waiting for Nginx... ($elapsed/$timeout seconds)"
            sleep 5
            elapsed=$((elapsed + 5))
          done

          # Show deployment status
          log_info "Container Status:"
          sudo docker-compose ps

          # Cleanup old images
          log_info "Cleaning up old Docker images..."
          sudo docker image prune -af --filter "until=72h" || true

          # Remove old backups (keep last 5)
          log_info "Cleaning up old backups..."
          ls -dt /tmp/backup-* 2>/dev/null | tail -n +6 | xargs rm -rf 2>/dev/null || true

          log_success "Deployment completed successfully!"
          PUBLIC_IP=$(curl -s ifconfig.me 2>/dev/null || echo "N/A")
          log_success "Application accessible at: http://$PUBLIC_IP"
          DEPLOY_SCRIPT

      - name: Verify Deployment
        id: verify
        if: steps.deployment.outcome == 'success'
        run: |
          echo "üîç Verifying external accessibility..."

          # Wait a bit for services to stabilize
          sleep 10

          MAX_ATTEMPTS=5
          ATTEMPT=0
          SUCCESS=false

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Verification attempt $ATTEMPT/$MAX_ATTEMPTS..."

            # Check Nginx health
            if curl -f -s --max-time 10 http://${{ secrets.EC2_HOST }}/health > /dev/null 2>&1; then
              echo "‚úÖ Nginx is accessible"

              # Check API health
              if curl -f -s --max-time 10 http://${{ secrets.EC2_HOST }}/api/health > /dev/null 2>&1; then
                echo "‚úÖ API is accessible through Nginx"
                SUCCESS=true
                break
              else
                echo "‚ö†Ô∏è API check failed, retrying..."
              fi
            else
              echo "‚ö†Ô∏è Nginx check failed, retrying..."
            fi

            if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
              sleep 10
            fi
          done

          if [ "$SUCCESS" = true ]; then
            echo "url=http://${{ secrets.EC2_HOST }}" >> $GITHUB_OUTPUT
            echo "status=success" >> $GITHUB_OUTPUT
            echo "‚úÖ Deployment verification successful!"
            echo "üåê Application is live at: http://${{ secrets.EC2_HOST }}"
            echo "üì° API endpoint: http://${{ secrets.EC2_HOST }}/api"
          else
            echo "status=warning" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è External verification failed, but deployment may still be working"
            echo "üí° Please verify EC2 security group allows HTTP (port 80) access"
            exit 1
          fi

      - name: Deployment Metrics
        if: always()
        run: |
          START_TIME=${{ steps.deployment-start.outputs.deployment-time }}
          END_TIME=$(date -u +%s)
          DURATION=$((END_TIME - START_TIME))

          echo "üìä Deployment Metrics"
          echo "===================="
          echo "Duration: ${DURATION}s ($((DURATION / 60))m $((DURATION % 60))s)"
          echo "Status: ${{ steps.deployment.outcome }}"
          echo "Commit: ${{ github.sha }}"
          echo "Branch: main"
          echo "Tests: ${{ github.event.workflow_run.conclusion }}"
          echo "Verification: ${{ steps.verify.outputs.status || 'skipped' }}"

      - name: Deployment Summary
        if: always()
        run: |
          echo "# üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Status | ${{ steps.deployment.outcome == 'success' && '‚úÖ Success' || '‚ùå Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Commit | \`${{ github.sha }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Branch | main |" >> $GITHUB_STEP_SUMMARY
          echo "| Tests | ${{ github.event.workflow_run.conclusion }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Verification | ${{ steps.verify.outputs.status || 'N/A' }} |" >> $GITHUB_STEP_SUMMARY

          if [ "${{ steps.deployment.outcome }}" == "success" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## üåê Application URLs" >> $GITHUB_STEP_SUMMARY
            echo "- **Application:** http://${{ secrets.EC2_HOST }}" >> $GITHUB_STEP_SUMMARY
            echo "- **API:** http://${{ secrets.EC2_HOST }}/api" >> $GITHUB_STEP_SUMMARY
            echo "- **Health Check:** http://${{ secrets.EC2_HOST }}/api/health" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üìã Deployment Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Method:** SSH + Docker Compose" >> $GITHUB_STEP_SUMMARY
          echo "- **Strategy:** Blue-Green with Rollback" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by:** ${{ github.event.workflow_run.event }}" >> $GITHUB_STEP_SUMMARY

      - name: Notify on Failure
        if: failure()
        run: |
          echo "::error::Deployment failed! Check the logs for details."
          echo "Previous deployment may have been restored automatically."

      - name: Cleanup SSH Keys
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key.pem
          echo "üßπ SSH keys cleaned up"
